<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Enhanced Snake — Play Now</title>
  <style>
    :root{
      --bg-1: #0f0919;
      --panel-bg: #0f0919;
      --ui-white: #ffffff;
      --light-green: #64ff64;
      --green: #00ff00;
      --dark-green: #00b400;
      --gold: #ffd700;
      --red: #ff3232;
      --grid: #787878;
    }
    html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;background:linear-gradient(180deg,#0d0712,#05040a);}
    .wrap{display:flex;align-items:flex-start;gap:20px;padding:20px;max-width:1200px;margin:0 auto;}
    .ui{width:260px;color:var(--ui-white);}
    canvas{background:#080415;display:block;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.6);}
    .btn{display:inline-block;padding:10px 14px;background:#222;color:#fff;border-radius:6px;text-decoration:none;cursor:pointer;margin-top:10px}
    .muted{opacity:.85;color:#ddd;font-size:13px}
    h1{color:var(--ui-white);font-size:20px;margin:0 0 8px}
    .stat{margin:8px 0;font-weight:bold}
    .small{font-size:13px;color:#ddd}
    .center{display:flex;align-items:center;gap:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="game" width="700" height="700"></canvas>
    </div>
    <div class="ui">
      <h1>Enhanced Snake — Play Now</h1>
      <div class="muted small">Arrow keys to move • Press R to restart • Q to quit (close tab)</div>
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="speed">Speed: 8</div>
      <div class="stat" id="combo">Combo: 1.0x</div>
      <button id="restartBtn" class="btn">Restart</button>
      <div style="height:18px"></div>
      <div class="small muted">Host instructions below — 1-click deploy to GitHub Pages or Netlify.</div>
      <div style="height:8px"></div>
      <a id="ghTemplate" class="btn" href="#" target="_blank">Open on GitHub (instructions)</a>
    </div>
  </div>

<script>
/* ---------- Game config (mirror of your Python constants) ---------- */
const GRID_SIZE=25, GRID_W=28, GRID_H=24;
const WIDTH = GRID_W*GRID_SIZE, HEIGHT = GRID_H*GRID_SIZE + 140; // allow UI space
const BASE_FPS = 8;

/* ---------- canvas setup ---------- */
const canvas = document.getElementById('game');
canvas.width = WIDTH;
canvas.height = HEIGHT;
const ctx = canvas.getContext('2d');

/* ---------- state ---------- */
let snake, food, particles, score, combo, running, gameOver, lastTick, fps;
const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const comboEl = document.getElementById('combo');
document.getElementById('restartBtn').onclick = ()=> init();

/* ---------- helpers ---------- */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function getFps(scr){
  if(scr<30) return BASE_FPS;
  if(scr<60) return BASE_FPS+2;
  if(scr<90) return BASE_FPS+4;
  return BASE_FPS+5;
}

/* ---------- Particle ---------- */
class Particle {
  constructor(x,y,color){
    this.x=x; this.y=y; this.vx=(Math.random()*6-3); this.vy=(Math.random()*6-3);
    this.color=color; this.life=60; this.maxLife=60;
  }
  update(){ this.x+=this.vx; this.y+=this.vy; this.vy+=0.1; this.life--; }
  draw(g){
    const alpha=this.life/this.maxLife;
    const size = Math.max(1, Math.floor(5 * alpha));
    g.save();
    g.globalAlpha = Math.min(1, 0.9 * alpha);
    g.fillStyle = this.color;
    g.beginPath();
    g.arc(this.x, this.y, size, 0, Math.PI*2);
    g.fill();
    g.restore();
  }
}

/* ---------- Snake ---------- */
class Snake {
  constructor(){
    this.reset();
  }
  reset(){
    this.body = [{x: Math.floor(GRID_W/2), y: Math.floor(GRID_H/2)}];
    this.dir = {x:1,y:0};
    this.growPending = 0;
    this.trailAlpha = [255];
  }
  head(){ return this.body[0]; }
  move(){
    const head = this.head();
    const newHead = {x: head.x + this.dir.x, y: head.y + this.dir.y};
    this.body.unshift(newHead);
    if(this.growPending>0){ this.growPending--; this.trailAlpha.unshift(255);}
    else { this.body.pop(); if(this.trailAlpha.length) this.trailAlpha.pop(); }
    if(this.trailAlpha.length>0) this.trailAlpha[0]=255;
    if(this.trailAlpha.length>1) this.trailAlpha[this.trailAlpha.length-1] = Math.max(80, this.trailAlpha[this.trailAlpha.length-1]-15);
  }
  grow(){ this.growPending += 2; }
  changeDir(nx,ny){
    if(nx === -this.dir.x && ny === -this.dir.y) return;
    this.dir={x:nx,y:ny};
  }
  checkCollision(){
    const h = this.head();
    if(h.x<0 || h.x>=GRID_W || h.y<0 || h.y>=GRID_H) return true;
    for(let i=1;i<this.body.length;i++){ if(this.body[i].x===h.x && this.body[i].y===h.y) return true; }
    return false;
  }
  draw(g){
    for(let i=0;i<this.body.length;i++){
      const seg = this.body[i];
      const alpha = (i < this.trailAlpha.length) ? this.trailAlpha[i]/255 : Math.max(80, 255 - i*15)/255;
      let color;
      if(i===0) color = '#00ff00';
      else {
        const fade = i/Math.max(1,this.body.length);
        const r = Math.floor(0*(1-fade) + 100*fade);
        const gr = Math.floor(180*(1-fade) + 150*fade);
        const b = Math.floor(0*(1-fade) + 50*fade);
        color = `rgba(${r},${gr},${b},${alpha})`;
      }
      // glow
      g.save();
      const gx = seg.x * GRID_SIZE, gy = seg.y * GRID_SIZE;
      g.beginPath();
      g.globalAlpha = 0.12 * alpha;
      g.fillStyle = '#64ff64';
      g.arc(gx + GRID_SIZE/2, gy + GRID_SIZE/2, Math.max(8, GRID_SIZE*0.4 + i*0.1), 0, Math.PI*2);
      g.fill();
      g.restore();
      // main rect
      g.save();
      g.globalAlpha = alpha;
      g.fillStyle = color;
      g.fillRect(gx+3, gy+3, GRID_SIZE-6, GRID_SIZE-6);
      g.strokeStyle = '#fff';
      g.lineWidth = 1;
      g.strokeRect(gx+3, gy+3, GRID_SIZE-6, GRID_SIZE-6);
      g.restore();
    }
  }
}

/* ---------- Food ---------- */
class Food {
  constructor(snake){
    this.snake = snake;
    this.respawn();
    this.pulse = 0;
  }
  respawn(){
    while(true){
      const x=randInt(0,GRID_W-1), y=randInt(0,GRID_H-1);
      if(!this.snake.body.some(p=>p.x===x && p.y===y)){ this.pos={x,y}; break; }
    }
    this.pulse=0;
  }
  update(){ this.pulse += 0.15; }
  draw(g){
    const pulseScale = 1 + 0.15*Math.sin(this.pulse);
    const size = Math.floor(GRID_SIZE*0.65 * pulseScale);
    const x = this.pos.x * GRID_SIZE, y = this.pos.y * GRID_SIZE;
    // glow ring
    g.save();
    g.globalAlpha = 0.6;
    g.fillStyle = '#ffd700';
    g.beginPath();
    g.arc(x + GRID_SIZE/2, y + GRID_SIZE/2, size/2 + 10, 0, Math.PI*2);
    g.fill();
    g.restore();
    // main food
    g.save();
    g.fillStyle = '#ff3232';
    g.beginPath();
    g.arc(x + GRID_SIZE/2, y + GRID_SIZE/2, size/2, 0, Math.PI*2);
    g.fill();
    g.lineWidth = 2;
    g.strokeStyle = '#ffd700';
    g.stroke();
    g.restore();
  }
}

/* ---------- draw grid & UI ---------- */
function drawGrid(g){
  g.save();
  g.strokeStyle = '#787878';
  g.lineWidth = 1;
  for(let x=0;x<=GRID_W;x++){
    g.beginPath(); g.moveTo(x*GRID_SIZE,0); g.lineTo(x*GRID_SIZE, GRID_H*GRID_SIZE); g.stroke();
  }
  for(let y=0;y<=GRID_H;y++){
    g.beginPath(); g.moveTo(0,y*GRID_SIZE); g.lineTo(GRID_W*GRID_SIZE, y*GRID_SIZE); g.stroke();
  }
  g.restore();
}

function drawUI(){
  // top panel
  const g = ctx;
  // background gradient for UI area
  const grad = ctx.createLinearGradient(0,0,0,120);
  grad.addColorStop(0, 'rgb(15,8,25)');
  grad.addColorStop(1, 'rgb(40,20,55)');
  g.fillStyle = grad;
  g.fillRect(0,0,WIDTH,120);

  // texts
  g.save();
  g.fillStyle = '#fff';
  g.font = '20px Arial';
  g.fillText('Score: ' + score, 20, 30);
  g.fillStyle = '#64ff64';
  g.fillText('Speed: ' + fps, 20, 60);
  g.fillStyle = '#ffd700';
  g.fillText('Combo: ' + combo.toFixed(1) + 'x', 20, 90);

  g.fillStyle = '#ddd';
  g.font = '14px Arial';
  g.fillText('Arrow Keys to Move', 20, HEIGHT - 20);
  g.restore();
}

/* ---------- main loop ---------- */
function init(){
  snake = new Snake();
  food = new Food(snake);
  particles = [];
  score = 0;
  combo = 1.0;
  running = true;
  gameOver = false;
  lastTick = performance.now();
  fps = getFps(score);
  scoreEl.textContent = 'Score: 0';
  speedEl.textContent = 'Speed: ' + fps;
  comboEl.textContent = 'Combo: 1.0x';
}

function spawnExplosion(x,y){
  for(let i=0;i<35;i++){
    const col = ['#ffd700','#ff9664','#c832ff','#ff3232'][Math.floor(Math.random()*4)];
    particles.push(new Particle(x,y,col));
  }
}

/* keyboard */
const KEY = {ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false};
window.addEventListener('keydown', (e)=>{
  if(gameOver){
    if(e.key==='r' || e.key==='R'){ init(); return; }
    if(e.key==='q' || e.key==='Q'){ window.close(); return; }
  } else {
    if(e.key === 'ArrowUp') snake.changeDir(0,-1);
    if(e.key === 'ArrowDown') snake.changeDir(0,1);
    if(e.key === 'ArrowLeft') snake.changeDir(-1,0);
    if(e.key === 'ArrowRight') snake.changeDir(1,0);
  }
});

/* mouse/touch quick controls for mobile: simple directional tap zones */
canvas.addEventListener('click', (ev)=>{
  // left half -> left, right half -> right, top/bottom zones for up/down
  const rect=canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(y < 120) return; // clicking UI
  const gx = x - (WIDTH - GRID_W*GRID_SIZE)/2;
  const gy = y - 120;
  if(Math.abs(gx - (snake.head().x*GRID_SIZE + GRID_SIZE/2)) > Math.abs(gy - (snake.head().y*GRID_SIZE + GRID_SIZE/2))){
    if(gx < snake.head().x*GRID_SIZE + GRID_SIZE/2) snake.changeDir(-1,0);
    else snake.changeDir(1,0);
  } else {
    if(gy < snake.head().y*GRID_SIZE + GRID_SIZE/2) snake.changeDir(0,-1);
    else snake.changeDir(0,1);
  }
});

/* game tick */
function tick(){
  if(gameOver) return;
  snake.move();
  food.update();

  // eat
  const h = snake.head();
  if(h.x === food.pos.x && h.y === food.pos.y){
    score += Math.floor(10 * combo);
    combo += 0.15;
    snake.grow();
    spawnExplosion(food.pos.x * GRID_SIZE + GRID_SIZE/2, food.pos.y*GRID_SIZE + GRID_SIZE/2);
    food.respawn();
    fps = getFps(score);
    scoreEl.textContent = 'Score: ' + score;
    speedEl.textContent = 'Speed: ' + fps;
    comboEl.textContent = 'Combo: ' + combo.toFixed(1) + 'x';
  }

  // update particles
  for(let i = particles.length-1;i>=0;i--){
    particles[i].update();
    if(particles[i].life <= 0) particles.splice(i,1);
  }

  if(snake.checkCollision()){
    gameOver = true;
  }
}

/* render */
function render(){
  // draw UI area + background
  // full background gradient
  const g = ctx;
  const fullGrad = g.createLinearGradient(0,0,0,HEIGHT);
  fullGrad.addColorStop(0,'rgb(15,8,25)');
  fullGrad.addColorStop(1,'rgb(5,2,10)');
  g.fillStyle = fullGrad;
  g.fillRect(0,0,WIDTH,HEIGHT);

  drawUI();

  // game surface (centered)
  const gx = (WIDTH - GRID_W*GRID_SIZE)/2;
  const gy = 120;
  // dark game background
  g.save();
  g.fillStyle = '#080415';
  g.fillRect(gx, gy, GRID_W*GRID_SIZE, GRID_H*GRID_SIZE);
  g.restore();

  // set clipping to game rect
  g.save();
  g.translate(gx, gy);
  drawGrid(g);
  snake.draw(g);
  food.draw(g);
  for(const p of particles) p.draw(g);
  g.restore();

  if(gameOver){
    g.save();
    g.fillStyle = 'rgba(15,8,25,0.95)';
    g.fillRect(0,0,WIDTH,HEIGHT);
    g.fillStyle = '#ff3232';
    g.font = '48px Arial';
    g.fillText('GAME OVER', WIDTH/2 - 150, HEIGHT/3);
    g.fillStyle = '#fff';
    g.font = '28px Arial';
    g.fillText('Final Score: ' + score, WIDTH/2 - 120, HEIGHT/2);
    g.font = '18px Arial';
    g.fillText('Press R to Restart or Q to Quit', WIDTH/2 - 130, HEIGHT/2 + 60);
    g.restore();
  }
}

/* main loop with variable fps */
function loop(now){
  requestAnimationFrame(loop);
  if(!lastTick) lastTick = now;
  const msPerTick = 1000 / fps;
  if(now - lastTick >= msPerTick){
    tick();
    lastTick = now;
  }
  render();
}

/* start */
init();
requestAnimationFrame(loop);
</script>
</body>
</html>
